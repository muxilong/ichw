# Cache 的结构与工作原理
## 为什么要使用Cache

***

主存的速度始终低于CPU的速度，为了不降低CPU的工作效率，在CPU与主存之间加一级缓存（cache），

这样CPU可以直接从缓存中读取所需要的信息，而不必空等主存影响效率。

## 使用cache背后的原理——程序访问的局部性原理

***
　　
> Cache的出现主要解决CPU不直接访问主存， 只与高速Cache交换信息。那么，这是否可能呢?

通过大量典型程序的分析，发现CPU从主存取指令或取数据在一定时间内，只是对主存局部地址区域的访问。

这是由于指令和数据在主存内都是连续存放的，并且有些指令和数据往往会被多次调用(如子程序循环程序和一些常数).

这使得CPU在执行程序时，访存具有相对的局部性，这就叫程序访问的局部性原理。

根据这一原理，很容易设想，只要将CPU近期要用到的程序和数据， 提前从主存送到Cache， 那么就可以做到CPU在一定时间内只访问Cache。

## cache的工作原理

***
(1)主存和缓存中的字都是按块进行存储，且缓存中的块数远小于主存中的。
详情如下：
主存由$2^n$个可编址的字组成，每个字有惟一的n位地址。

为了与Cache映射，将主存与缓存都分成若干块，每块内又包含若干个字，并使它们的块大小相同(即块内的字数相同)。

这就将主存的地址分成两段：

高m位表示主存的块地址， 低b位表示块内地址，则$2^m$＝M表示主存的块数。

同样缓存的地址也分为两段：

高c位表示缓存的块号，低b位表示块内地址，则$2^c$=C表示缓存块数，且C远小于M。

主存与缓存地址中都用b位表示其块内字数，即B=$2^b$ 反映了块的大小，称B为块长。
（2）命中与不命中
　　任何时刻都有一些主存块处在缓存块中。CPU欲读取主存某字时，有两种可能：一种是所需要的数已在缓存中，即可直接访问Cache(CPU与Cache之间通常一次传送一个字)，此种情况称为CPU访问Cache命中；另一种是所需的字不在Cache内，此时需将该字所在的主存整个字块一次调入Cache中，此种情况称CPU访问Cache不命中。如果主存块已调入缓存块，则称该主存块与缓存块建立了对应关系。
（3）tag 标记
　　由于缓存的块数C远小于主存的块数M，因此，一个缓存块不能惟一地、永久地只对应一个主存块，故每个缓存块需设一个标记用来表示当前存放的是哪一个主存块，该标记的内容相当于主存块的编号。CPU读信息时，要将主存地址的高m位 (或m位中的一部分)与缓存块的标记进行比较，以判断所读的信息是否已在缓存中。
（4）命中率，命中率与块长和容量的关系
　　Cache的容量与块长是影响Cache效率的重要因素，通常用“命中率”来衡量Cache的效率。命中率是指CPU要访问的信息已在Cache内的比率。一般而言，Cache容量越大，其CPU的命中率就越高。当然也没必要太大，太大会增加成本，而且当Cache容量达到一定值时，命中率已不因容量的增大而有明显的提高。因此，Cache容量是总成本价与命中率的折衷值。
　　块长与命中率之间的关系更为复杂，它取决于各程序的局部特性。当块由小到大增长时，起初会因局部性原理使命中率有所提高。由局部性原理指出，在已被访问字的附近，近期也可能被访问，因此，增大块长，可将更多有用字存入在缓存，提高其命中率。可是，倘若继续增大块长，很可能命中率反而下降，是因为所装入缓存的有用数据反而少于被替换掉的有用数据。由于块长的增大，导致缓存中块数的减少，而新装入的块要覆盖旧块，很可能出现少数块刚刚装入就又被覆盖，因此命中率反而下降。再者，块增大后，追加上的字，距离所访问的字更远，也更少会在近期用到。块长的最优值是很难确定的，一般每块取4至8个可编址单位(字或字节)较好，也可取一个主存周期所能调出主存的信息长度。
（4）cache的基本结构
它由Cache存储体、地址映象变换机构、Cache替换机构几大模块组成。
　　(1)Cache存储体。Cache存储体以块为单位与主存交换信息，为加速Cache与主存之间的调动，主存大多采用多体结构，且Cache访存的优先级最高。
　　(2)地址映象变换机构。它是将CPU送来的主存地址转换为Cache地址。由于主存和Cache的块大小相同，块内地址都是相对于块的起始地址的偏移量(即低位地址相同)，因此地址变换主要是主存的块号(高位地址)与Cache块号间的转换。
　　如果转换后的Cache块已与CPU欲访问的主存块建立了对应关系，即命中，则CPU可直接访问Cache存储体。如果转换后的Cache块与CPU欲访问的主存块未建立对应关系，即不命中。此刻CPU在访问主存时，不仅将该字从主存取出，同时将它所在的主存块一并调入Cache，供CPU使用。当然，此刻能将主存块调入Cache内，也是由于cache原来处于未被装满的状态。反之，倘若Cache原来已被装满，即已无法将主存块调入Cache内时，就得采用替换策略。
　　(3)替换机构。当Cache内容已满，无法接受来自主存块的信息时，就由Cache内的替换机构由按一定的替换算法来确定应从Cache内移出哪个块返回主存，而把新的主存块调入Cache。
